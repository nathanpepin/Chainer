using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace Chainer.SourceGen;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class ChainerSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "ChainerGenerators";
    private const string AttributeName = "RegisterChainsAttribute";
    private const string AttributeFullPath = $"{Namespace}.{AttributeName}";

    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
            [AttributeUsage(AttributeTargets.Class)]
            public sealed class {{AttributeName}}<TContext>(params Type[] types) : Attribute where TContext : class, ICloneable, new()
            {
            }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.attributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (ClassDeclarationSyntax, bool attributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeSyntax in classDeclarationSyntax
                     .AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    public class Registration(string className, string contextName)
    {
        public List<string> Handlers { get; } = [];

        public StringBuilder AddGenerateCode(StringBuilder? stringBuilder = null)
        {
            stringBuilder ??= new StringBuilder();

            stringBuilder.Append("services.TryAddScoped<");
            stringBuilder.Append(className);
            stringBuilder.Append(">();");

            foreach (var handler in Handlers)
            {
                stringBuilder.Append("services.TryAddScoped<IChainHandler<");
                stringBuilder.Append(contextName);
                stringBuilder.Append(">, ");
                stringBuilder.Append(handler);
                stringBuilder.Append(">();");
            }

            return stringBuilder;
        }
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        List<Registration> registrations = [];

        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var className = classSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var attribute = classSymbol.GetAttributes().First(x => x.AttributeClass?.AssociatedSymbol?.Name is AttributeFullPath);
        }

        StringBuilder generatedCodeBuilder = new();

        foreach (var registration in registrations)
            registration.AddGenerateCode(generatedCodeBuilder);

        var code =
            $$"""
              // <auto-generated/>

              using System;
              using System.Collections.Generic;

              namespace {{Namespace}}
              {
                  public static class ChainerRegistrar
                  {
                      public static void RegisterChains(this IServiceCollection services)
                      {
                          {{generatedCodeBuilder}}
                      }
                  }
              }
              """;

        context.AddSource($"ChainerRegistrar.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}